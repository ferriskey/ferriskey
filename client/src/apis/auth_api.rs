/*
 * FerrisKey API
 *
 * FerrisKey API
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: pro.nathaelbonnal@gmail.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`auth_handler`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthHandlerError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authenticate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticateError {
    Status400(models::ApiError),
    Status401(models::ApiError),
    Status500(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`burn_recovery_code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BurnRecoveryCodeError {
    Status400(models::ApiErrorResponse),
    Status401(models::ApiErrorResponse),
    Status403(models::ApiErrorResponse),
    Status404(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`challenge_otp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChallengeOtpError {
    Status400(models::ApiErrorResponse),
    Status401(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`exchange_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExchangeTokenError {
    Status401(models::ApiErrorResponse),
    Status404(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_recovery_codes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateRecoveryCodesError {
    Status400(models::ApiErrorResponse),
    Status404(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_certs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertsError {
    Status400(models::ApiErrorResponse),
    Status401(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_jwks_json`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJwksJsonError {
    Status400(models::ApiErrorResponse),
    Status401(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_openid_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOpenidConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_userinfo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserinfoError {
    Status401(),
    Status403(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`introspect_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntrospectTokenError {
    Status401(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logout_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogoutGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logout_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogoutPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`registration_handler`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegistrationHandlerError {
    Status400(models::ApiErrorResponse),
    Status401(models::ApiErrorResponse),
    Status403(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_magic_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendMagicLinkError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`setup_otp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetupOtpError {
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePasswordError {
    Status400(models::ApiErrorResponse),
    Status403(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_magic_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyMagicLinkError {
    Status400(),
    Status401(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_otp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyOtpError {
    Status400(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webauthn_public_key_authenticate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebauthnPublicKeyAuthenticateError {
    Status400(models::ApiErrorResponse),
    Status401(models::ApiErrorResponse),
    Status403(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webauthn_public_key_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebauthnPublicKeyCreateError {
    Status400(models::ApiErrorResponse),
    Status401(models::ApiErrorResponse),
    Status403(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webauthn_public_key_create_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebauthnPublicKeyCreateOptionsError {
    Status401(models::ApiErrorResponse),
    Status403(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webauthn_public_key_request_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebauthnPublicKeyRequestOptionsError {
    Status401(models::ApiErrorResponse),
    Status403(models::ApiErrorResponse),
    Status500(models::ApiErrorResponse),
    UnknownValue(serde_json::Value),
}

/// Initiates the authentication process for a user in a specific realm.
pub async fn auth_handler(
    configuration: &configuration::Configuration,
    realm_name: &str,
    response_type: Option<&str>,
    client_id: Option<&str>,
    redirect_uri: Option<&str>,
    scope: Option<&str>,
    state: Option<&str>,
) -> Result<(), Error<AuthHandlerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_query_response_type = response_type;
    let p_query_client_id = client_id;
    let p_query_redirect_uri = redirect_uri;
    let p_query_scope = scope;
    let p_query_state = state;

    let uri_str = format!(
        "{}/realms/{realm_name}/protocol/openid-connect/auth",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_response_type {
        req_builder = req_builder.query(&[("response_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_id {
        req_builder = req_builder.query(&[("client_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redirect_uri {
        req_builder = req_builder.query(&[("redirect_uri", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_scope {
        req_builder = req_builder.query(&[("scope", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthHandlerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn authenticate(
    configuration: &configuration::Configuration,
    realm_name: &str,
    authenticate_request: models::AuthenticateRequest,
) -> Result<models::AuthenticateResponse, Error<AuthenticateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_authenticate_request = authenticate_request;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/authenticate",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_authenticate_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Using a recovery code allows a user to bypass a MFA challenge
pub async fn burn_recovery_code(
    configuration: &configuration::Configuration,
    realm_name: &str,
    burn_recovery_code_request: models::BurnRecoveryCodeRequest,
) -> Result<models::BurnRecoveryCodeResponse, Error<BurnRecoveryCodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_burn_recovery_code_request = burn_recovery_code_request;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/burn-recovery-code",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_burn_recovery_code_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BurnRecoveryCodeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BurnRecoveryCodeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BurnRecoveryCodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Challenges the user to provide a One-Time Password (OTP) for authentication. This is typically used in multi-factor authentication scenarios.
pub async fn challenge_otp(
    configuration: &configuration::Configuration,
    realm_name: &str,
    challenge_otp_request: models::ChallengeOtpRequest,
) -> Result<models::ChallengeOtpResponse, Error<ChallengeOtpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_challenge_otp_request = challenge_otp_request;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/challenge-otp",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_challenge_otp_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChallengeOtpResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChallengeOtpResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChallengeOtpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Exchanges a token for a JWT token. This endpoint allows clients to exchange various types of tokens (like authorization codes, refresh tokens, etc.) for a JWT token.
pub async fn exchange_token(
    configuration: &configuration::Configuration,
    realm_name: &str,
    token_request_validator: models::TokenRequestValidator,
) -> Result<models::JwtToken, Error<ExchangeTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_token_request_validator = token_request_validator;

    let uri_str = format!(
        "{}/realms/{realm_name}/protocol/openid-connect/token",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_token_request_validator);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JwtToken`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JwtToken`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExchangeTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Generates recovery codes that allows the user to bypass a MFA challenge
pub async fn generate_recovery_codes(
    configuration: &configuration::Configuration,
    realm_name: &str,
    generate_recovery_codes_request: models::GenerateRecoveryCodesRequest,
) -> Result<models::GenerateRecoveryCodesResponse, Error<GenerateRecoveryCodesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_generate_recovery_codes_request = generate_recovery_codes_request;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/generate-recovery-codes",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_generate_recovery_codes_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GenerateRecoveryCodesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GenerateRecoveryCodesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateRecoveryCodesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves the JSON Web Key (JWK) keys for a specific realm, used for verifying JWT tokens.
pub async fn get_certs(
    configuration: &configuration::Configuration,
    realm_name: &str,
) -> Result<models::GetCertsResponse, Error<GetCertsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;

    let uri_str = format!(
        "{}/realms/{realm_name}/protocol/openid-connect/certs",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetCertsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetCertsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCertsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves the JSON Web Key Set (JWKS) for a specific realm, used by resource servers to validate JWT signatures.
pub async fn get_jwks_json(
    configuration: &configuration::Configuration,
    realm_name: &str,
) -> Result<models::GetCertsResponse, Error<GetJwksJsonError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;

    let uri_str = format!(
        "{}/realms/{realm_name}/protocol/openid-connect/jwks.json",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetCertsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetCertsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJwksJsonError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves the OpenID Connect configuration for a specific realm. This endpoint provides metadata about the OpenID Connect provider, including endpoints for authorization, token issuance, introspection, user information, and JWKs.
pub async fn get_openid_configuration(
    configuration: &configuration::Configuration,
    realm_name: &str,
) -> Result<models::GetOpenIdConfigurationResponse, Error<GetOpenidConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;

    let uri_str = format!(
        "{}/realms/{realm_name}/.well-known/openid-configuration",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetOpenIdConfigurationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetOpenIdConfigurationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOpenidConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves the user information for the authenticated user in a specific realm.
pub async fn get_userinfo(
    configuration: &configuration::Configuration,
    realm_name: &str,
) -> Result<models::UserInfoResponse, Error<GetUserinfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;

    let uri_str = format!(
        "{}/realms/{realm_name}/protocol/openid-connect/userinfo",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserinfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuth2/OIDC Token Introspection (RFC 7662). Only confidential clients may call this endpoint using client_secret_basic or client_secret_post. Authorization requires the caller's service account to have the role `introspect` (treated as the `introspect` scope).
pub async fn introspect_token(
    configuration: &configuration::Configuration,
    realm_name: &str,
    introspect_request_validator: models::IntrospectRequestValidator,
) -> Result<models::TokenIntrospectionResponse, Error<IntrospectTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_introspect_request_validator = introspect_request_validator;

    let uri_str = format!(
        "{}/realms/{realm_name}/protocol/openid-connect/token/introspect",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_introspect_request_validator);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenIntrospectionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenIntrospectionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntrospectTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Ends the user's OP session. Supports id_token_hint, post_logout_redirect_uri, state, and client_id.
pub async fn logout_get(
    configuration: &configuration::Configuration,
    realm_name: &str,
    id_token_hint: Option<&str>,
    post_logout_redirect_uri: Option<&str>,
    state: Option<&str>,
    client_id: Option<&str>,
) -> Result<(), Error<LogoutGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_query_id_token_hint = id_token_hint;
    let p_query_post_logout_redirect_uri = post_logout_redirect_uri;
    let p_query_state = state;
    let p_query_client_id = client_id;

    let uri_str = format!(
        "{}/realms/{realm_name}/protocol/openid-connect/logout",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_id_token_hint {
        req_builder = req_builder.query(&[("id_token_hint", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_post_logout_redirect_uri {
        req_builder = req_builder.query(&[("post_logout_redirect_uri", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_id {
        req_builder = req_builder.query(&[("client_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogoutGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Ends the user's OP session. Supports id_token_hint, post_logout_redirect_uri, state, and client_id.
pub async fn logout_post(
    configuration: &configuration::Configuration,
    realm_name: &str,
    logout_request_validator: models::LogoutRequestValidator,
) -> Result<(), Error<LogoutPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_logout_request_validator = logout_request_validator;

    let uri_str = format!(
        "{}/realms/{realm_name}/protocol/openid-connect/logout",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_logout_request_validator);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogoutPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Register a new user in the specified realm
pub async fn registration_handler(
    configuration: &configuration::Configuration,
    realm_name: &str,
    registration_request: models::RegistrationRequest,
) -> Result<models::JwtToken, Error<RegistrationHandlerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_registration_request = registration_request;

    let uri_str = format!(
        "{}/realms/{realm_name}/protocol/openid-connect/registrations",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_registration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JwtToken`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JwtToken`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RegistrationHandlerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuth2 token revocation endpoint (RFC 7009). Revokes access or refresh tokens for the requesting client.
pub async fn revoke_token(
    configuration: &configuration::Configuration,
    realm_name: &str,
    revoke_token_request_validator: models::RevokeTokenRequestValidator,
) -> Result<(), Error<RevokeTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_revoke_token_request_validator = revoke_token_request_validator;

    let uri_str = format!(
        "{}/realms/{realm_name}/protocol/openid-connect/revoke",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_revoke_token_request_validator);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Sends a magic link to the user's email for passwordless authentication. The link contains a unique token that can be used to verify the user's identity.
pub async fn send_magic_link(
    configuration: &configuration::Configuration,
    realm_name: &str,
    send_magic_link_request: models::SendMagicLinkRequest,
) -> Result<models::SendMagicLinkResponse, Error<SendMagicLinkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_send_magic_link_request = send_magic_link_request;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/send-magic-link",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_send_magic_link_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SendMagicLinkResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SendMagicLinkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendMagicLinkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Sets up a One-Time Password (OTP) for user authentication. This is typically used in multi-factor authentication scenarios.
pub async fn setup_otp(
    configuration: &configuration::Configuration,
    realm_name: &str,
) -> Result<models::SetupOtpResponse, Error<SetupOtpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/setup-otp",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SetupOtpResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SetupOtpResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetupOtpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn update_password(
    configuration: &configuration::Configuration,
    realm_name: &str,
    update_password_request: models::UpdatePasswordRequest,
) -> Result<models::UpdatePasswordResponse, Error<UpdatePasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_update_password_request = update_password_request;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/update-password",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_update_password_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdatePasswordResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdatePasswordResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdatePasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Verifies the magic link token and completes the authentication flow. Returns authentication status and redirect URL with authorization code.
pub async fn verify_magic_link(
    configuration: &configuration::Configuration,
    realm_name: &str,
    token_id: &str,
    magic_token: &str,
) -> Result<models::AuthenticateResponse, Error<VerifyMagicLinkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_query_token_id = token_id;
    let p_query_magic_token = magic_token;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/verify-magic-link",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("token_id", &p_query_token_id.to_string())]);
    req_builder = req_builder.query(&[("magic_token", &p_query_magic_token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifyMagicLinkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Verifies the One-Time Password (OTP) provided by the user. This is typically used in multi-factor authentication scenarios.
pub async fn verify_otp(
    configuration: &configuration::Configuration,
    realm_name: &str,
    otp_verify_request: models::OtpVerifyRequest,
) -> Result<models::VerifyOtpResponse, Error<VerifyOtpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_otp_verify_request = otp_verify_request;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/verify-otp",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_otp_verify_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyOtpResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyOtpResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifyOtpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Attempt authentication using a WebAuthnAssertionResponse payload for webauthn authentication. See https://w3c.github.io/webauthn/#dictdef-authenticationresponsejson and https://w3c.github.io/webauthn/#authenticatorassertionresponse
pub async fn webauthn_public_key_authenticate(
    configuration: &configuration::Configuration,
    realm_name: &str,
    body: serde_json::Value,
) -> Result<models::AuthenticationAttemptResponse, Error<WebauthnPublicKeyAuthenticateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_body = body;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/webauthn-public-key-authenticate",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticationAttemptResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticationAttemptResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebauthnPublicKeyAuthenticateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Saving a webauthn public key to use it for authentication attempts or MFA later.
pub async fn webauthn_public_key_create(
    configuration: &configuration::Configuration,
    realm_name: &str,
    body: serde_json::Value,
) -> Result<serde_json::Value, Error<WebauthnPublicKeyCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_body = body;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/webauthn-public-key-create",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebauthnPublicKeyCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Provides a full PublicKeyCredentialCreationOption payload for WebAuthn credential creation/authentication. The payload contains the challenge to resolve in B64Url form as described in the specs. The content is described here: https://w3c.github.io/webauthn/#dictdef-publickeycredentialcreationoptions.
pub async fn webauthn_public_key_create_options(
    configuration: &configuration::Configuration,
    realm_name: &str,
) -> Result<serde_json::Value, Error<WebauthnPublicKeyCreateOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/webauthn-public-key-create-options",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebauthnPublicKeyCreateOptionsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Provides a full PublicKeyCredentialRequestOption payload for webauthn authentication. See https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions and https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptionsjson
pub async fn webauthn_public_key_request_options(
    configuration: &configuration::Configuration,
    realm_name: &str,
) -> Result<serde_json::Value, Error<WebauthnPublicKeyRequestOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;

    let uri_str = format!(
        "{}/realms/{realm_name}/login-actions/webauthn-public-key-request-options",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebauthnPublicKeyRequestOptionsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
