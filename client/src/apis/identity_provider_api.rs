/*
 * FerrisKey API
 *
 * FerrisKey API
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: pro.nathaelbonnal@gmail.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`create_identity_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIdentityProviderError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_identity_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIdentityProviderError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_identity_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIdentityProviderError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_identity_providers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIdentityProvidersError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_identity_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateIdentityProviderError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Creates a new identity provider configuration for the specified realm. The identity provider will be used for social login (Google, GitHub, etc.) or OIDC/SAML federation.
pub async fn create_identity_provider(
    configuration: &configuration::Configuration,
    realm_name: &str,
    create_identity_provider_validator: models::CreateIdentityProviderValidator,
) -> Result<models::IdentityProviderResponse, Error<CreateIdentityProviderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_body_create_identity_provider_validator = create_identity_provider_validator;

    let uri_str = format!(
        "{}/realms/{realm_name}/identity-providers",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_identity_provider_validator);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateIdentityProviderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes an identity provider from the realm. This action is irreversible. Users who have linked accounts with this identity provider will no longer be able to use it for authentication.
pub async fn delete_identity_provider(
    configuration: &configuration::Configuration,
    realm_name: &str,
    alias: &str,
) -> Result<models::DeleteIdentityProviderResponse, Error<DeleteIdentityProviderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_path_alias = alias;

    let uri_str = format!(
        "{}/realms/{realm_name}/identity-providers/{alias}",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name),
        alias = crate::apis::urlencode(p_path_alias)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteIdentityProviderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteIdentityProviderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteIdentityProviderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves the details of a specific identity provider by its alias. Sensitive configuration values (like client secrets) are redacted in the response.
pub async fn get_identity_provider(
    configuration: &configuration::Configuration,
    realm_name: &str,
    alias: &str,
) -> Result<models::IdentityProviderResponse, Error<GetIdentityProviderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_path_alias = alias;

    let uri_str = format!(
        "{}/realms/{realm_name}/identity-providers/{alias}",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name),
        alias = crate::apis::urlencode(p_path_alias)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIdentityProviderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves all identity providers configured for the specified realm. Optionally returns a brief representation with fewer fields.
pub async fn list_identity_providers(
    configuration: &configuration::Configuration,
    realm_name: &str,
    brief_representation: Option<bool>,
) -> Result<models::IdentityProvidersResponse, Error<ListIdentityProvidersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_query_brief_representation = brief_representation;

    let uri_str = format!(
        "{}/realms/{realm_name}/identity-providers",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_brief_representation {
        req_builder = req_builder.query(&[("brief_representation", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProvidersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProvidersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListIdentityProvidersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates an existing identity provider configuration. Only the fields provided in the request body will be updated. The alias cannot be changed after creation.
pub async fn update_identity_provider(
    configuration: &configuration::Configuration,
    realm_name: &str,
    alias: &str,
    update_identity_provider_validator: models::UpdateIdentityProviderValidator,
) -> Result<models::UpdateIdentityProviderResponse, Error<UpdateIdentityProviderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_realm_name = realm_name;
    let p_path_alias = alias;
    let p_body_update_identity_provider_validator = update_identity_provider_validator;

    let uri_str = format!(
        "{}/realms/{realm_name}/identity-providers/{alias}",
        configuration.base_path,
        realm_name = crate::apis::urlencode(p_path_realm_name),
        alias = crate::apis::urlencode(p_path_alias)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_update_identity_provider_validator);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateIdentityProviderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateIdentityProviderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateIdentityProviderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
