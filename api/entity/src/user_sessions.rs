//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.0



use sea_orm :: entity :: prelude :: * ;

# [derive (Copy , Clone , Default , Debug , DeriveEntity)] pub struct Entity ;

impl EntityName for Entity { fn table_name (& self) -> & str { "user_sessions" } }

# [derive (Clone , Debug , PartialEq , DeriveModel , DeriveActiveModel , Eq)] pub struct Model { pub id : Uuid , pub user_id : Uuid , pub realm_id : Uuid , pub user_agent : Option < String > , pub ip_address : Option < String > , pub created_at : DateTime , pub expires_at : DateTime , }

# [derive (Copy , Clone , Debug , EnumIter , DeriveColumn)] pub enum Column { Id , UserId , RealmId , UserAgent , IpAddress , CreatedAt , ExpiresAt , }

# [derive (Copy , Clone , Debug , EnumIter , DerivePrimaryKey)] pub enum PrimaryKey { Id , }

impl PrimaryKeyTrait for PrimaryKey { type ValueType = Uuid ; fn auto_increment () -> bool { false } }

# [derive (Copy , Clone , Debug , EnumIter)] pub enum Relation { Realms , Users , }

impl ColumnTrait for Column { type EntityName = Entity ; fn def (& self) -> ColumnDef { match self { Self :: Id => ColumnType :: Uuid . def () , Self :: UserId => ColumnType :: Uuid . def () , Self :: RealmId => ColumnType :: Uuid . def () , Self :: UserAgent => ColumnType :: String (StringLen :: N (255u32)) . def () . null () , Self :: IpAddress => ColumnType :: String (StringLen :: N (255u32)) . def () . null () , Self :: CreatedAt => ColumnType :: DateTime . def () , Self :: ExpiresAt => ColumnType :: DateTime . def () , } } }

impl RelationTrait for Relation { fn def (& self) -> RelationDef { match self { Self :: Realms => Entity :: belongs_to (super :: realms :: Entity) . from (Column :: RealmId) . to (super :: realms :: Column :: Id) . into () , Self :: Users => Entity :: belongs_to (super :: users :: Entity) . from (Column :: UserId) . to (super :: users :: Column :: Id) . into () , } } }

impl Related < super :: realms :: Entity > for Entity { fn to () -> RelationDef { Relation :: Realms . def () } }

impl Related < super :: users :: Entity > for Entity { fn to () -> RelationDef { Relation :: Users . def () } }

impl ActiveModelBehavior for ActiveModel { }